# Buffer Overflow

## buffer-overflow-1.0

下载可执行文件，采用IDA调试，可见`char buffer[0x10];`一句对应变量为`var_20 = byte ptr -20h`，也就是说它在栈当中的位置为`-0x20`；对应地，`long magic`所在位置为`-0x8`，二者间隔为`0x18`，大于`0x10`,**buffer和magic在栈中存在间隔，需要填充**。

```python
# 先填充前0x18个字符
b'123456789012345678901234'
# 再输出payload
p64(0xdeadbeef)
```

## buffer-overflow-1.1

间隔和上一题相同，修改的变量为函数指针。采用IDA查看`read_flag`函数地址得到`0x4012D7`，则将payload末尾改为`0x4012D7`即可。

## buffer-overflow-3.1

该题应用的是 Off-By-Null漏洞，利用了scanf会在输入字符串后加\0的特性。

```c++
  scanf("%256s*c", a);
```

这个输入语句读入了一个长度为`0x100`的字符串，并忽略其后的其他输入；因此，前一题的 Off-by-one 思路在这里不能奏效。然而，当输入字符串长度大于等于`0x100`时，从字符串起始地址开始向后数的第`0x101`个字节将会被写入`\x00`。

通过IDA查看反汇编代码，在输入字符串的 vuln_func 栈中，字符串之后即为 old rbp。溢出的这个 0 字节会使该 rbp 的地址从 [0x12345678] (示例) 变成 [0x12345600] , 也就是说该栈基址向低地址方向（也就是向后）移动 [0, 0x100] 位，正好落在我们刚刚输入的字符串中（的不确定某个位置）。

复习汇编代码，leave 会执行两条指令：

```asm
mov rsp rbp
pop rbp
```
之后， ret 会在 pop 的 rbp 基础上 （这里没有绕太明白，实践经验先写上）jmp ret_addr。根据之前的分析，该 addr 会从原来正常返回的调用者 func addr 变成我们字符串中的某 4 个字节；因此，输入字符串中不断重复 read_flag 函数的地址就可以碰撞并且劫持返回方向到 read_flag 处。


